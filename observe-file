#!/usr/bin/env perl

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use IO::File;
STDOUT->autoflush(1); STDERR->autoflush(1);

use Linux::Inotify2;
use Path::Class qw(file dir);
use Time::HiRes qw();

BEGIN {
    my $debug_flag = $ENV{SMART_COMMENTS} || $ENV{SMART_DEBUG} || $ENV{SC};
    if ($debug_flag) {
        my @p = map { '#'x$_ } ($debug_flag =~ /([345])\s*/g);
        eval {
            require Smart::Comments;
            import Smart::Comments @p;
        };
    }
}

my $command;
my @files;
Getopt::Long::Configure("bundling");
GetOptions(
    'command|c=s' => \$command,
    'exec|x=s'    => sub { $command = $_[1]; push @files, $_[1]; },
    'help|h|?'    => sub { pod2usage() },
    ) or pod2usage;

for my $o (map {-d $_?dir($_):file($_)} @ARGV) {
    if ($o->is_dir) {
        $o->recurse(callback => sub {
                        my $oc = shift;
                        return if $o eq $oc;
                        if (!$oc->is_dir) {
                            push @files, $oc->absolute->stringify;
                        }
                    });
    } else {
        push @files, $o->absolute->stringify;
    }
}

### files: \@files
pod2usage unless $command;

my $n    = Linux::Inotify2->new;
my $mask = IN_CLOSE_WRITE | IN_MOVE_SELF;

$n->watch($_, $mask) for @files, '/dev/stdin';
run_command($command);
print "-- \n";

while (1) {
    my @ev = $n->read; # block

    if (@ev > 0) {
        # call cancel and re-watch to prevent firing multiple events.
        $_->w->cancel for @ev;
        Time::HiRes::sleep 0.2; # workaround for Can't exec "XXX": Text file busy
        run_command($command);
        print "-- \n";
        $n->watch($_->fullname, $mask) for @ev;
    } else {
        ; # warn "read error: $!";
    }
}

sub run_command {
    my($command) = @_;

     # use sysread, syswrite for no buffering
    open my $cmdout, '-|', $command or die "$!";
    my($buf, $r);
    while ($r = sysread $cmdout, $buf, 80) {
        syswrite STDOUT, $buf, $r;
    }
    close $cmdout;
}

__END__

=head1 NAME

B<observe-file> - do arbitrary command when observed files have changed

=head1 SYNOPSIS

B<observe-file> B<-c> I<COMMAND> ( I<FILE> | I<DIR> ) [ ( I<FILE> | I<DIR> ) ... ]

B<observe-file> B<-x> I<FILE>

=head1 OPTIONS

=over 4

=item B<-c> I<COMMAND>

Do command I<COMMAND> when following files have changed.

You can also specify directory name to observe files in directory recursively.

=item B<-x> I<FILE>

observe I<FILE> and do I<FILE>.

This is equivalent:

    observe-file -c I<FILE> I<FILE>

=back

=head1 EXAMPLES

=head2 edit and run simple script

    observe-file -x ./foo.pl

    observe-file -c "perl -wcT ./foo.pl && ./foo.pl" ./foo.pl

=head2 build and run automatically

    observe-file -c "make myprog && ./myprog"  myprog.c myprog.h libfoo.c

    observe-file -c "make myprog && ./myprog"  src/

=head2 reload Firefox when contents have changed

    observe-file -c "reload-firefox localhost"  *.html *.css *.js

    observe-file -c "deploy && reload-firefox mymacbook"  webapp/

"reload-filefox" is simple shell script to request Firefox with MozRepl.

    #!/bin/sh
    [ $# -eq 1 -o $# -eq 2 ] || { echo 'usage: reload-firefox HOST PORT'; exit 1; }
    host=$1
    port=${2:-4242}
    
    echo "reload: $host:$port"
    cat <<EOF | nc $host $port
    content.location.reload(true)
    repl.quit()
    EOF
    echo

=head1 REPOSITORY

L<http://github.com/hirose31/observe-file>

=head1 COPYRIGHT & LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# for Emacsen
# Local Variables:
# mode: cperl
# cperl-indent-level: 4
# indent-tabs-mode: nil
# coding: utf-8
# End:

# vi: set ts=4 sw=4 sts=0 :
