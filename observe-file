#!/usr/bin/env perl

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;

BEGIN {
    my $debug_flag = $ENV{SMART_COMMENTS} || $ENV{SMART_DEBUG} || $ENV{SC};
    if ($debug_flag) {
        my @p = map { '#'x$_ } ($debug_flag =~ /([345])\s*/g);
        use UNIVERSAL::require;
        Smart::Comments->use(@p);
    }
}

use File::ChangeNotify;
use Path::Class qw(file dir);
use Time::HiRes qw();

my $command;
my(%files, %parent_dirs, %dirs);
Getopt::Long::Configure("bundling");
GetOptions(
    'command|c=s' => \$command,
    'exec|x=s'    => sub { $command = $_[1]; push @ARGV, $_[1]; },
    'help|h|?'    => sub { pod2usage() },
    ) or pod2usage;

# File::ChangeNotify はファイルを監視対象にできないので、ファイルが
# 指定された場合はその親ディレクトリを監視対象にする。そして、イベントが
# 発火したら、イベント発火起因のファイルパスとコマンドラインで指定された
# ファイルパスを比較して本気発火するかどうかを判断する。

for my $o (map {-d $_?dir($_):file($_)} @ARGV) {
    if ($o->is_dir) {
        $dirs{$o->absolute->stringify}++;
    } else {
        $files{$o->absolute->stringify}++;
        $parent_dirs{ $o->absolute->parent }++;
    }
}

### %files
### %parent_dirs
### %dirs

pod2usage unless $command;

my $watcher = File::ChangeNotify->instantiate_watcher(
    directories => [ keys(%parent_dirs), keys(%dirs) ],
   );
print "with ", ref $watcher, "\n";


run_command($command);
print "-- \n";

while (my @events = $watcher->wait_for_events()) {
    # workaround for Can't exec "XXX": Text file
    # and fire modify event twice with Inotify.
    Time::HiRes::sleep 0.2;
    push @events, $watcher->new_events();
    ### events: @events

    my $fire = 0;
    for my $e (@events) {
        if ($e->path =~ m{(/.#|_flymake\.?\w*$|~$)}) {
            next;
        } elsif (exists $files{ $e->path }) {
            ### f: $e->path
            $fire = 1;
            last;
        } elsif (exists $dirs{ file($e->path)->parent }) {
            ### d: $e->path
            $fire = 1;
            last;
        } else {
            ### ?: $e->path
            ;
        }
    }

    if ($fire) {
        run_command($command);
        print "-- \n";
    }
}

sub run_command {
    my($command) = @_;

    # use sysread, syswrite for no buffering
    open my $cmdout, '-|', $command or die "$!";
    my($buf, $r);
    while ($r = sysread $cmdout, $buf, 80) {
        syswrite STDOUT, $buf, $r;
    }
    close $cmdout;
}

__END__

=head1 NAME

B<observe-file> - do arbitrary command when observed files have changed

=head1 SYNOPSIS

B<observe-file> B<-c> I<COMMAND> ( I<FILE> | I<DIR> ) [ ( I<FILE> | I<DIR> ) ... ]

B<observe-file> B<-x> I<FILE>

=head1 OPTIONS

=over 4

=item B<-c> I<COMMAND>

Do command I<COMMAND> when following files have changed.

You can also specify directory name to observe files in directory recursively.

=item B<-x> I<FILE>

observe I<FILE> and do I<FILE>.

This is equivalent:

    observe-file -c I<FILE> I<FILE>

=back

=head1 EXAMPLES

=head2 edit and run simple script

    observe-file -x ./foo.pl

    observe-file -c "perl -wcT ./foo.pl && ./foo.pl" ./foo.pl

=head2 build and run automatically

    observe-file -c "make myprog && ./myprog"  myprog.c myprog.h libfoo.c

    observe-file -c "make myprog && ./myprog"  src/

=head2 reload Firefox when contents have changed

    observe-file -c "reload-firefox localhost"  *.html *.css *.js

    observe-file -c "deploy && reload-firefox mymacbook"  webapp/

"reload-filefox" is simple shell script to request Firefox with MozRepl.

    #!/bin/sh
    [ $# -eq 1 -o $# -eq 2 ] || { echo 'usage: reload-firefox HOST PORT'; exit 1; }
    host=$1
    port=${2:-4242}
    
    echo "reload: $host:$port"
    cat <<EOF | nc $host $port
    content.location.reload(true)
    repl.quit()
    EOF
    echo

=head1 REPOSITORY

L<http://github.com/hirose31/observe-file>

=head1 COPYRIGHT & LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# for Emacsen
# Local Variables:
# mode: cperl
# cperl-indent-level: 4
# indent-tabs-mode: nil
# coding: utf-8
# End:

# vi: set ts=4 sw=4 sts=0 :
