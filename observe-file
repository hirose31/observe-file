#!/bin/bash
#
# perform arbitrary command when change file or directory
#

prog=${0##*/}
basedir=${0%/*}

die() { echo "[ABORT] $@"; exit 1; }

_color_() {
  color=$1; shift
  echo -e "\e[${color}${@}\e[0m"
}
fg_GREEN()   { _color_ "32;1m" $@; }

begin_command() { fg_GREEN ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> "; }
end_command()   { fg_GREEN "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< "; }

usage() {
  [ -z "$@" ] || echo "[error] $@" 1>&2
  cat <<EOUSAGE
[usage]
  $prog [-1] [-h?] -c COMMAND FILE|DIR [ FILE|DIR ] ...
  $prog [-1] [-h?] -x FILE
    -1     oneshot
    -h -?  help
EOUSAGE
  exit 2
}

command=
observe_targets=
oneshot=

OPTIND_OLD=$OPTIND
OPTIND=1
while getopts "h?c:x:" opt; do
  case $opt in
    c)
      command=$OPTARG
      observe_targets='' # set later
      ;;
    x)
      command=$OPTARG
      observe_targets=$command
      ;;
    1)
      oneshot=1
      ;;
    ?|h)
      usage
      ;;
  esac
done
shift $(($OPTIND - 1))
OPTIND=$OPTIND_OLD

if [ -z "$observe_targets" ]; then
  observe_targets="$@"
fi
if [ -z "$observe_targets" ]; then
  usage "missing arguments"
fi

pid=

kill_child() {
  if [ ! -z "$pid" ]; then
    echo "kill $pid"
    kill -TERM $pid
    echo "wait $pid"
    wait $pid
  fi >/dev/null 2>&1
}

wait_for_change() {
  inotifywait -r \
    -e 'close_write,create,delete' \
    --excludei '(.*\.swp$|\.git/|service/|\.#.*|.*~$|_flymake)' \
    "$@" 2>/dev/null
  kill_child
}

trap kill_child EXIT

# echo "target : $observe_targets"
# echo "command: $command:"

while :; do
  begin_command
  bash -c "$command" &
  pid=$!
  wait_for_change $observe_targets
done
