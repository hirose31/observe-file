#!/usr/bin/env perl

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;

BEGIN {
    my $debug_flag = $ENV{SMART_COMMENTS} || $ENV{SMART_DEBUG} || $ENV{SC};
    if ($debug_flag) {
        my @p = map { '#'x$_ } ($debug_flag =~ /([345])\s*/g);
        use UNIVERSAL::require;
        Smart::Comments->use(@p);
    }
}

use Filesys::Notify::Simple;
use Path::Class qw(file dir);
use Time::HiRes qw();

my $command;
my(%files, %parent_dirs, %dirs);
Getopt::Long::Configure("bundling");
GetOptions(
    'command|c=s' => \$command,
    'exec|x=s'    => sub { $command = $_[1]; push @ARGV, $_[1]; },
    'help|h|?'    => sub { pod2usage() },
    ) or pod2usage;

# File::ChangeNotify はファイルを監視対象にできないので、ファイルが
# 指定された場合はその親ディレクトリを監視対象にする。そして、イベントが
# 発火したら、イベント発火起因のファイルパスとコマンドラインで指定された
# ファイルパスを比較して本気発火するかどうかを判断する。

for my $o (map {-d $_?dir($_):file($_)} @ARGV) {
    if ($o->is_dir) {
        $dirs{ $o->absolute->stringify}++;
    } else {
        $files{$o->absolute->stringify}++;
        $parent_dirs{$o->parent->absolute->stringify}++;
    }
}

### %files
### %parent_dirs
### %dirs

pod2usage unless $command;

my $watcher = do {
    if ($^O eq 'darwin') {#fixme
        Filesys::Notify::Simple->new([keys(%parent_dirs), keys(%dirs)]);
    } else {
        Filesys::Notify::Simple->new([keys(%files), keys(%dirs)]);
    }
};

run_command($command);
print "-- \n";

my $last_fire = 0;
while (1) {
    $watcher->wait(
        sub {
            ### events: @_
            my $now = Time::HiRes::time();

            # workaround for Can't exec "XXX": Text file
            Time::HiRes::sleep 0.2;

            my $fire = 0;
            for my $e (values %{{map { $_->{path} => $_ } @_}}) {
                ### e: $e

                if ($e->{path} =~ m{(/.#|_flymake\.?\w*$|~$)}) {
                    next;
                } elsif (exists $files{ $e->{path} }
                         or exists $dirs{  file($e->{path})->parent }
                     ) {
                    ### interest f/d: $e->{path}
                    $fire = 1;
                } else {
                    ### ??: $e->{path}
                    ;
                }
            }

            # 前回発火時刻から 1.0 秒以上経過しているときだけ、コマンド
            # を実行する。
            # Inotify2 の場合、ファイルを保存したときに極短時間
            # で 2 回発火しちゃうのでその対策でげす。
            ### dt: $now - $last_fire
            if ($fire && $now - $last_fire >= 1.0) {
                run_command($command);
                print "-- \n";

                $last_fire = $now;
            }
        });
}

sub run_command {
    my($command) = @_;

    # use sysread, syswrite for no buffering
    open my $cmdout, '-|', $command or die "$!";
    my($buf, $r);
    while ($r = sysread $cmdout, $buf, 80) {
        syswrite STDOUT, $buf, $r;
    }
    close $cmdout;
}

__END__

=head1 NAME

B<observe-file> - do arbitrary command when observed files have changed

=head1 SYNOPSIS

B<observe-file> B<-c> I<COMMAND> ( I<FILE> | I<DIR> ) [ ( I<FILE> | I<DIR> ) ... ]

B<observe-file> B<-x> I<FILE>

=head1 OPTIONS

=over 4

=item B<-c> I<COMMAND>

Do command I<COMMAND> when following files have changed.

You can also specify directory name to observe files in directory recursively.

=item B<-x> I<FILE>

observe I<FILE> and do I<FILE>.

This is equivalent:

    observe-file -c I<FILE> I<FILE>

=back

=head1 EXAMPLES

=head2 edit and run simple script

    observe-file -x ./foo.pl

    observe-file -c "perl -wcT ./foo.pl && ./foo.pl" ./foo.pl

=head2 build and run automatically

    observe-file -c "make myprog && ./myprog"  myprog.c myprog.h libfoo.c

    observe-file -c "make myprog && ./myprog"  src/

=head2 reload Firefox when contents have changed

    observe-file -c "reload-firefox localhost"  *.html *.css *.js

    observe-file -c "deploy && reload-firefox mymacbook"  webapp/

"reload-filefox" is simple shell script to request Firefox with MozRepl.

    #!/bin/sh
    [ $# -eq 1 -o $# -eq 2 ] || { echo 'usage: reload-firefox HOST PORT'; exit 1; }
    host=$1
    port=${2:-4242}
    
    echo "reload: $host:$port"
    cat <<EOF | nc $host $port
    content.location.reload(true)
    repl.quit()
    EOF
    echo

=head1 REPOSITORY

L<http://github.com/hirose31/observe-file>

=head1 COPYRIGHT & LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# for Emacsen
# Local Variables:
# mode: cperl
# cperl-indent-level: 4
# indent-tabs-mode: nil
# coding: utf-8
# End:

# vi: set ts=4 sw=4 sts=0 :
